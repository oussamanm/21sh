*** interpreter & compiler

*Lexical Analysis : 
    is the first phase of a compiler , it takes the modifies sources
    form language preprocessors that are written in the form of senteces.
    - the LA breaks these syntaxes into a series of tokens, by removing 
    any whitespace or comments in the source code.
    ex: int value = 100; ==> int (keyword), value (identidier), = (operator) ...
    (the compiler breaks the submitted source code into meaningful elements 
    called LEXEMES and generates a sequence of TOKENS from the lexemes)

*Parsing || syntactic analysis || syntax analysis :
    during syntax analysis the compiler use the sequence of tokens to generate
    a tree-like data structure called Abstract Syntax Tree, AST
    is also the phase where eventual syntax errors are detected and reported

*Semantic Analysis :
    During semantic analysis , the compiler uses the AST ot check if the program
    is consistent with all the rules of the source programming language.
    - semantic analysis encompasses :
        . Type inference = check if a type is successfully inferred.
        . Type checking : check that all value being assigned to vrb have the correct type
        . Symbol management : the compiler maintains a data structure called symbol table
            which contains information about all symbol (or names)
            the compiler use the symbol table to answer questions such as is this vrb declared
            use ? are there 2 vrb with the same names...

* Intermediate Code generation
    teh compiler uses the annotated AST to generate an intermediate  and machine-independent 
    low-level code.


pre preprocessor
compiler
assembler : machine code
linker : tool is used to link all the part of program together for execution
loader : load all of them into memory and the the program is executed
memory


*Quoting : used to remove the special meaning of certain character or words to the shell
			

test1 aaaaa bbb cccc dddd
(str,remp,7,5)
protonmail
lavabit

static void	ft_call_cmdss(char **str_arg, char ***environ)
{
	char		**args_pipe;
	t_pipes		*st_pipes;
	int			i = 0;
	int			len;
	int			pid;
	int			fds[2];

	args_pipe = ft_str_split_q(str_arg, "|");
	st_pipes = ft_strr_list(args_pipe);

	len = ft_lst_count(st_pipes);
	//ft_lst_print(st_pipes, 2);

	while (st_pipes != NULL)
	{
		if (pipe(fds) == -1)
			ft_err_exit("Error in Pipe Function \n");
		st_pipes->fds[1] = fds[1];
		if (st_pipes->next != NULL)
			st_pipes->next->fds[0] = fds[0];
		if ((pid = fork()) == 0)
		{
			printf("Start with : fds[0] = %d and fds[1] = %d \n ", fds[0], fds[1]);
			/// Close unsed Read end of Child1
			if (i == 0 && close(st_pipes->fds[0]) == -1)
				perror("Error close read in child");
			
			//// *** Duplcating
				// pair even	// Duplcating STD_OUT on Write end of pipe
				// unpair odd 	// Duplcating STD_IN on Read end of pipe
		
			if (i != 0 && dup2(st_pipes->fds[0] , 0) == -1)
				perror("Error in dub STD_IN");

			if (dup2(st_pipes->fds[1] , 1) == -1)
				perror("Error in dub STD_OUT");
			else if (close(st_pipes->fds[1]) == -1)
				perror("Error in Close fds[0] in child 2");
			
			//execve(st_pipes->cmd, (char *[2]){args_pipe[0],"NULL"}, *environ);
			ft_split_cmd(st_pipes->cmd, *environ);
		}
		else if (pid > 0)
		{
			wait(NULL);
		}
		st_pipes = st_pipes->next;
	}
	/*
		argv = ft_str_split_q(str_arg, " \t");

		/// Correct Args
		ft_corr_args(&argv[1], *environ);
		/// Check if cmd is Builtin
		rtn = ft_check_built(argv, environ);
		/// Call cmd from system
		rtn = (rtn == 0) ? ft_call_child(argv, *environ, 0) : rtn;
		(rtn == -1) ? ft_print_error(CMD_NF, argv[0], "", 0) : NULL;
		ft_strrdel(argv);
	*/
	ft_strrdel(args_pipe);
}
